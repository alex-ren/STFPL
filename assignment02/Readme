To build the program, please run
>> make all

To do the test, please run
>> ./testall.sh
All the cpp files and executables are located in the TEST folder.


Updates:
  Type checking

  Type inference

  generating Intermediate Representation

  >> (current)
  generaing C++ code (to the screen)

Caution:
  Doesn't support closure yet. Source file containing closure leads to segment fault.
  No gabbage collector yet.

Record (for functionality)
  Type inference including tuple of variant length

  Generating C++ file: supporting recusive function call, function as first class object

Record (for developers)
  Treat all functions as unary ones in the C++ level.
  
  ?? handle this --> not supported since c is not function definition
  val rec a = lam (x: int): int -> int => let
    val f = lam (x: int) => x + 1
    val d = c
  in f end
  and c = a (1)

 
  ?? handle this --> not supported since c is not function definition
  val rec a = lam (x: int): int -> int => c
  and c = a (1)
   
File Desc:
  absyn.sats => abstract syntax tree (e0xp, t0yp), generated by the parser
  interp0.sats => interpreter for ABS before type checking
  trans1.sats => type checking, transform the ABS e1xp and t1yp


About Type Checking / Inference
  The number of arguments is part of the function type.
  The type of a function may be:
    <1> (X, Y, Z) -> R
    <3> (X, Y, Z) -> R
    <0> () -> R
    <0> () -> ()

  
  ===============================
  val rec a = lam (x) => b (x, y)
  and b = lam (x) => 3
  ===============================
  For this kind of vardec, the type checker would scan twice. First time,
  it would try to get the types of a and b if they are functions. Second
  time it does the type checking based on that a and b are of such types.


  ===============================
  val a = lam (x) => 4
  val b = lam (x) => 3
  ===============================
  For this kind of vardec, the type checker only scans once. If a and b
  are not type annotated, then their types are set according to their
  definition.


  unit is a type and it's equivalent to writing ().


  Refer to TEST/list.stfpl for usage of list type
  Library functions of list operations such as list_cons are constructors.
  They can be applied to different kinds list. But the user-defined functions
  such as 
  ===============================
  val fn = lam (x: list, y: list): list
  ===============================
  is not a template function at all. Its type needs to be inferred. And once
  its type is inferred, then it is fixed.

  
  So far, the program should not go on to trans2, if trans1 has type conflicts.
  todo check the result of trans1 to see whether there is exp1 whose type
  hasn't been inferred yet.

  
