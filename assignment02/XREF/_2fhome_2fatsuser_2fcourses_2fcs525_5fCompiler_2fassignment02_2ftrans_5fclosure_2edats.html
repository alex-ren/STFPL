<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    .atsyntax {color:#E80000;background-color:#E0E0E0}
    .atsyntax span.comment {color:#787878;font-style:italic}
    .atsyntax span.extern  {color:#A52A2A}
    .atsyntax span.keyword {color:#000000;font-weight:bold}
    .atsyntax span.neuexp  {color:#800080}
    .atsyntax span.staexp  {color:#0000FF}
    .atsyntax span.dynexp  {color:#E80000}
    .atsyntax span.prfexp  {color:#009000}
    .atsyntax span.stacstdec  {text-decoration:none}
    .atsyntax span.stacstuse  {color:#0000CF;text-decoration:underline}
    .atsyntax span.dyncstdec  {text-decoration:none}
    .atsyntax span.dyncstimp  {color:#B80000;text-decoration:underline}
    .atsyntax span.dyncstuse  {color:#B80000;text-decoration:underline}
    body {color:#E80000;background-color:#E0E0E0}
  </style>
</head>
<body>
<pre class="atsyntax">


<span class="keyword">staload</span> <span class="staexp">"trans_closure.sats"</span>
<span class="keyword">staload</span> <span class="staexp">"trans1.sats"</span>
<span class="keyword">staload</span> <span class="staexp">"symbol.sats"</span>
<span class="keyword">staload</span> <span class="staexp">"error.sats"</span>

<span class="keyword">typedef</span> <span class="staexp"><a name="105"><span class="stacstdec">loc <span class="keyword">=</span> $Posloc<span class="keyword">.</span>location_t</span></a></span>

<span class="keyword">staload</span> <span class="staexp">_<span class="comment">(*anon*)</span> <span class="keyword">=</span> "symbol.dats"</span>

<span class="keyword">staload</span> <span class="staexp">_<span class="comment">(*anon*)</span> <span class="keyword">=</span> "prelude/DATS/list.dats"</span> 
<span class="keyword">staload</span> <span class="staexp">_<span class="comment">(*anon*)</span> <span class="keyword">=</span> "prelude/DATS/list0.dats"</span> 
<span class="keyword">staload</span> <span class="staexp">_<span class="comment">(*anon*)</span> <span class="keyword">=</span> "prelude/DATS/list_vt.dats"</span> 
<span class="keyword">staload</span> <span class="staexp">_<span class="comment">(*anon*)</span> <span class="keyword">=</span> "libats/DATS/funmap_avltree.dats"</span> 

<span class="keyword">staload</span> <span class="staexp">_<span class="comment">(*anon*)</span> <span class="keyword">=</span> "symbol.dats"</span>

<span class="keyword">#define</span> <span class="neuexp">:: list0_cons</span>
<span class="keyword">#define</span> <span class="neuexp">cons list0_cons</span>
<span class="keyword">#define</span> <span class="neuexp">nil list0_nil</span>

<span class="keyword">#define</span> <span class="neuexp">Some0 option0_some</span>
<span class="keyword">#define</span> <span class="neuexp">None0 option0_none</span>

<span class="comment">(* ****** ****** *)</span>
<span class="keyword">typedef</span> <span class="staexp"><a name="551"><span class="stacstdec">ctx <span class="keyword">=</span> symenv_t <span class="keyword">(</span>v1ar<span class="keyword">)</span></span></a></span>
<span class="keyword">val</span> ctx_nil <span class="keyword">=</span> symenv_make <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// empty context
</span>

<span class="keyword">fun</span> ctx2v1arlst <span class="keyword">(</span>Gamma<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v1arlst</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> s <span class="keyword">=</span> symenv_listize <span class="keyword">(</span>Gamma<span class="keyword">)</span>
  <span class="keyword">val</span> symlst <span class="keyword">=</span> list0_map_fun&lt; <span class="staexp"><span class="keyword">@(</span>symbol_t<span class="keyword">,</span> v1ar<span class="keyword">)</span></span><span class="keyword">&gt;&lt;</span><span class="staexp">v1ar</span><span class="keyword">&gt;</span> <span class="keyword">(</span>s<span class="keyword">,</span> <span class="keyword">lam</span> x <span class="keyword">=&gt;</span> x<span class="keyword">.</span>1<span class="keyword">)</span>
<span class="keyword">in</span>
  symlst
<span class="keyword">end</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="799"><span class="dyncstdec">trans_clo1_d1eclst <span class="keyword">(</span>decs<span class="keyword">:</span> <span class="staexp">d1eclst</span><span class="keyword">,</span> Gamma<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>ctx<span class="comment">(*new gamma*)</span><span class="keyword">,</span> ctx<span class="comment">(*esc*)</span><span class="keyword">)</span></span></span></a>
<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="889"><span class="dyncstdec">trans_clo1_d1ec <span class="keyword">(</span>dec<span class="keyword">:</span> <span class="staexp">d1ec</span><span class="keyword">,</span> Gamma<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>ctx<span class="keyword">,</span> ctx<span class="keyword">)</span></span></span></a>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="953"><span class="dyncstdec">trans_clo1_v1aldeclst <span class="keyword">(</span>valdecs<span class="keyword">:</span> <span class="staexp">v1aldeclst</span><span class="keyword">,</span> Gamma<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>ctx<span class="keyword">,</span> ctx<span class="keyword">)</span></span></span></a>
<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1032"><span class="dyncstdec">trans_clo1_v1aldeclst_rec <span class="keyword">(</span>valdecs<span class="keyword">:</span> <span class="staexp">v1aldeclst</span><span class="keyword">,</span> Gamma<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>ctx<span class="keyword">,</span> ctx<span class="keyword">)</span></span></span></a>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1116"><span class="dyncstdec">trans_clo1_v1aldec <span class="keyword">(</span>valdec<span class="keyword">:</span> <span class="staexp">v1aldec</span><span class="keyword">,</span> Gamma<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>ctx<span class="keyword">,</span> ctx<span class="keyword">)</span></span></span></a>
<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1188"><span class="dyncstdec">trans_clo1_v1aldec_rec <span class="keyword">(</span>valdec<span class="keyword">:</span> <span class="staexp">v1aldec</span><span class="keyword">,</span> Gamma<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>ctx<span class="keyword">,</span> ctx<span class="keyword">)</span></span></span></a>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1265"><span class="dyncstdec">trans_clo1_e1xp <span class="keyword">(</span>exp<span class="keyword">:</span> <span class="staexp">e1xp</span><span class="keyword">,</span> Gamma<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">ctx</span></span></a>
<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1321"><span class="dyncstdec">trans_clo1_e1xplst <span class="keyword">(</span>exps<span class="keyword">:</span> <span class="staexp">e1xplst</span><span class="keyword">,</span> Gamma<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">ctx</span></span></a>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1385"><span class="dyncstdec">trans_clo1_valdecs <span class="keyword">(</span>valdecs<span class="keyword">:</span> <span class="staexp">v1aldeclst</span><span class="keyword">,</span> Gamma<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>ctx<span class="keyword">,</span> ctx<span class="keyword">)</span></span></span></a>
<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1461"><span class="dyncstdec">trans_clo1_e1xplst <span class="keyword">(</span>exps<span class="keyword">:</span> <span class="staexp">e1xplst</span><span class="keyword">,</span> Gamma<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">ctx</span></span></a>

<span class="comment">(* the return type is ctx,
  but actually we just need a list of symbols
*)</span>
<span class="keyword">fun</span> trans_clo1_e1xp <span class="keyword">(</span>exp<span class="keyword">:</span> <span class="staexp">e1xp</span><span class="keyword">,</span> Gamma<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">ctx</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> exp_node <span class="keyword">=</span> exp<span class="keyword">.</span>e1xp_node
<span class="keyword">in</span>
  <span class="keyword">case+</span> exp_node <span class="keyword">of</span>
  <span class="keyword">|</span> E1XPann <span class="keyword">(</span>e<span class="keyword">,</span> t<span class="keyword">)</span> <span class="keyword">=&gt;</span> trans_clo1_e1xp <span class="keyword">(</span>e<span class="keyword">,</span> Gamma<span class="keyword">)</span>
  <span class="keyword">|</span> E1XPapp <span class="keyword">(</span>f<span class="keyword">,</span> args<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="keyword">val</span> esc1 <span class="keyword">=</span> trans_clo1_e1xp <span class="keyword">(</span>f<span class="keyword">,</span> Gamma<span class="keyword">)</span>
    <span class="keyword">val</span> esc2 <span class="keyword">=</span> trans_clo1_e1xp <span class="keyword">(</span>args<span class="keyword">,</span> Gamma<span class="keyword">)</span>
  <span class="keyword">in</span>
    symenv_merge <span class="keyword">(</span>esc1<span class="keyword">,</span> esc2<span class="keyword">)</span>
  <span class="keyword">end</span>
  <span class="keyword">|</span> E1XPbool _ <span class="keyword">=&gt;</span> ctx_nil
  <span class="keyword">|</span> E1XPfix <span class="keyword">(</span>f<span class="keyword">,</span> args<span class="keyword">,</span> body<span class="keyword">,</span> ref_esc<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="comment">// put f into ctx
</span>    <span class="keyword">val</span> new_gamma <span class="keyword">=</span> symenv_insert <span class="keyword">(</span>ctx_nil<span class="keyword">,</span> f<span class="keyword">.</span>v1ar_nam<span class="keyword">,</span> f<span class="keyword">)</span>
    <span class="keyword">val</span> sym_args <span class="keyword">=</span> list0_map_fun&lt;<span class="staexp">v1ar</span><span class="keyword">&gt;&lt;</span> <span class="staexp"><span class="keyword">@(</span>symbol_t<span class="keyword">,</span> v1ar<span class="keyword">)</span></span><span class="keyword">&gt;</span> <span class="keyword">(</span>
      args<span class="keyword">,</span> <span class="keyword">lam</span> x <span class="keyword">=&gt;</span> <span class="keyword">(</span>x<span class="keyword">.</span>v1ar_nam<span class="keyword">,</span> x<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">val</span> new_gamma <span class="keyword">=</span> symenv_inserts <span class="keyword">(</span>new_gamma<span class="keyword">,</span> sym_args<span class="keyword">)</span>
    <span class="keyword">val</span> esc <span class="keyword">=</span> trans_clo1_e1xp <span class="keyword">(</span>body<span class="keyword">,</span> new_gamma<span class="keyword">)</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>ref_esc := ctx2v1arlst <span class="keyword">(</span>esc<span class="keyword">)</span>
  <span class="keyword">in</span>
    symenv_sub <span class="keyword">(</span>esc<span class="keyword">,</span> Gamma<span class="keyword">)</span>
  <span class="keyword">end</span>
  <span class="keyword">|</span> E1XPif <span class="keyword">(</span>e_if<span class="keyword">,</span> e_then<span class="keyword">,</span> eo_else<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="keyword">val</span> esc1 <span class="keyword">=</span> trans_clo1_e1xp <span class="keyword">(</span>e_if<span class="keyword">,</span> Gamma<span class="keyword">)</span>
    <span class="keyword">val</span> esc2 <span class="keyword">=</span> trans_clo1_e1xp <span class="keyword">(</span>e_then<span class="keyword">,</span> Gamma<span class="keyword">)</span>
    <span class="keyword">val</span> esc3 <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> eo_else <span class="keyword">of</span>
                 <span class="keyword">|</span> Some0 e_else <span class="keyword">=&gt;</span> trans_clo1_e1xp <span class="keyword">(</span>e_else<span class="keyword">,</span> Gamma<span class="keyword">)</span>
                 <span class="keyword">|</span> None0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ctx_nil
                 <span class="keyword">)</span>
    <span class="keyword">val</span> esc <span class="keyword">=</span> symenv_merge <span class="keyword">(</span>esc1<span class="keyword">,</span> esc2<span class="keyword">)</span>
    <span class="keyword">val</span> esc <span class="keyword">=</span> symenv_merge <span class="keyword">(</span>esc<span class="keyword">,</span> esc3<span class="keyword">)</span>
  <span class="keyword">in</span>
    esc
  <span class="keyword">end</span>
  <span class="keyword">|</span> E1XPint _ <span class="keyword">=&gt;</span> ctx_nil
  <span class="keyword">|</span> E1XPlam <span class="keyword">(</span>args<span class="keyword">,</span> body<span class="keyword">,</span> ref_esc<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="keyword">val</span> sym_args <span class="keyword">=</span> list0_map_fun&lt;<span class="staexp">v1ar</span><span class="keyword">&gt;&lt;</span> <span class="staexp"><span class="keyword">@(</span>symbol_t<span class="keyword">,</span> v1ar<span class="keyword">)</span></span><span class="keyword">&gt;</span> <span class="keyword">(</span>
      args<span class="keyword">,</span> <span class="keyword">lam</span> x <span class="keyword">=&gt;</span> <span class="keyword">(</span>x<span class="keyword">.</span>v1ar_nam<span class="keyword">,</span> x<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">val</span> new_gamma <span class="keyword">=</span> symenv_inserts <span class="keyword">(</span>ctx_nil<span class="keyword">,</span> sym_args<span class="keyword">)</span>
    <span class="keyword">val</span> esc <span class="keyword">=</span> trans_clo1_e1xp <span class="keyword">(</span>body<span class="keyword">,</span> new_gamma<span class="keyword">)</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>ref_esc := ctx2v1arlst <span class="keyword">(</span>esc<span class="keyword">)</span>
  <span class="keyword">in</span>
    symenv_sub <span class="keyword">(</span>esc<span class="keyword">,</span> Gamma<span class="keyword">)</span>
  <span class="keyword">end</span>
  <span class="keyword">|</span> E1XPlet <span class="keyword">(</span>decs<span class="keyword">,</span> e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="keyword">val</span> <span class="keyword">(</span>Gamma1<span class="keyword">,</span> esc1<span class="keyword">)</span> <span class="keyword">=</span> trans_clo1_d1eclst <span class="keyword">(</span>decs<span class="keyword">,</span> Gamma<span class="keyword">)</span>
    <span class="keyword">val</span> esc2 <span class="keyword">=</span> trans_clo1_e1xp <span class="keyword">(</span>e<span class="keyword">,</span> Gamma1<span class="keyword">)</span>
  <span class="keyword">in</span>
    symenv_merge <span class="keyword">(</span>esc1<span class="keyword">,</span> esc2<span class="keyword">)</span>
  <span class="keyword">end</span>
  <span class="keyword">|</span> E1XPopr <span class="keyword">(</span>opr<span class="keyword">,</span> es<span class="keyword">)</span> <span class="keyword">=&gt;</span>
      trans_clo1_e1xplst <span class="keyword">(</span>es<span class="keyword">,</span> Gamma<span class="keyword">)</span>
  <span class="keyword">|</span> E1XPproj <span class="keyword">(</span>e<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> trans_clo1_e1xp <span class="keyword">(</span>e<span class="keyword">,</span> Gamma<span class="keyword">)</span>
  <span class="keyword">|</span> E1XPstr _ <span class="keyword">=&gt;</span> ctx_nil
  <span class="keyword">|</span> E1XPtup es <span class="keyword">=&gt;</span> trans_clo1_e1xplst <span class="keyword">(</span>es<span class="keyword">,</span> Gamma<span class="keyword">)</span>
  <span class="keyword">|</span> E1XPvar v <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="keyword">val</span> r <span class="keyword">=</span> symenv_lookup <span class="keyword">(</span>Gamma<span class="keyword">,</span> v<span class="keyword">.</span>v1ar_nam<span class="keyword">)</span>
  <span class="keyword">in</span>
    <span class="keyword">case+</span> r <span class="keyword">of</span>
    <span class="keyword">|</span> Some0 _ <span class="keyword">=&gt;</span> ctx_nil 
    <span class="keyword">|</span> None0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> symenv_insert <span class="keyword">(</span>ctx_nil<span class="keyword">,</span> v<span class="keyword">.</span>v1ar_nam<span class="keyword">,</span> v<span class="keyword">)</span>
  <span class="keyword">end</span>
<span class="comment">//  | E1XPfixclo _ =&gt; ETRACE_MSG_OPR ("trans_clo1_e1xp E1XPfixclo is found\n", ETRACE_LEVEL_ERROR,
</span><span class="comment">//                    abort (ERRORCODE_FORBIDDEN))
</span><span class="comment">//  | E1XPlamclo _ =&gt; ETRACE_MSG_OPR ("trans_clo1_e1xp E1XPlamclo is found\n", ETRACE_LEVEL_ERROR,
</span><span class="comment">//                    abort (ERRORCODE_FORBIDDEN))
</span><span class="keyword">end</span>

<span class="comment">(* extern fun trans_clo1_e1xplst (exps: e1xplst, Gamma: ctx): ctx *)</span>
<span class="keyword">implement</span> trans_clo1_e1xplst <span class="keyword">(</span>exps<span class="keyword">,</span> Gamma<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> gamma1 <span class="keyword">=</span> list0_fold_left&lt;<span class="staexp">ctx</span><span class="keyword">&gt;&lt;</span><span class="staexp">e1xp</span><span class="keyword">&gt;</span> <span class="keyword">(</span>
    <span class="keyword">lam</span> <span class="keyword">(</span>init<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=&gt;</span> symenv_merge <span class="keyword">(</span>init<span class="keyword">,</span> trans_clo1_e1xp <span class="keyword">(</span>x<span class="keyword">,</span> Gamma<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ctx_nil<span class="keyword">,</span> exps<span class="keyword">)</span>
<span class="keyword">in</span>
  gamma1
<span class="keyword">end</span>

<span class="comment">(* extern fun trans_clo1_d1eclst (decs: d1eclst, Gamma: ctx): (ctx, ctx) *)</span>
<span class="keyword">implement</span> trans_clo1_d1eclst <span class="keyword">(</span>decs<span class="keyword">,</span> Gamma<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> decs <span class="keyword">of</span>
  <span class="keyword">|</span> cons <span class="keyword">(</span>dec<span class="keyword">,</span> decs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="keyword">val</span> <span class="keyword">(</span>gamma1<span class="keyword">,</span> esc1<span class="keyword">)</span> <span class="keyword">=</span> trans_clo1_d1ec <span class="keyword">(</span>dec<span class="keyword">,</span> Gamma<span class="keyword">)</span>
    <span class="keyword">val</span> <span class="keyword">(</span>gamma2<span class="keyword">,</span> esc2<span class="keyword">)</span> <span class="keyword">=</span> trans_clo1_d1eclst <span class="keyword">(</span>decs1<span class="keyword">,</span> gamma1<span class="keyword">)</span>
    <span class="keyword">val</span> esc <span class="keyword">=</span> symenv_merge <span class="keyword">(</span>esc1<span class="keyword">,</span> esc2<span class="keyword">)</span>
  <span class="keyword">in</span>
    <span class="keyword">(</span>gamma2<span class="keyword">,</span> esc<span class="keyword">)</span>
  <span class="keyword">end</span>
  <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>Gamma<span class="keyword">,</span> ctx_nil<span class="keyword">)</span>

<span class="comment">(* extern fun trans_clo1_d1ec (dec: d1ec, Gamma: ctx): (ctx, ctx) *)</span>
<span class="keyword">implement</span> trans_clo1_d1ec <span class="keyword">(</span>dec<span class="keyword">,</span> Gamma<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> loc <span class="keyword">=</span> dec<span class="keyword">.</span>d1ec_loc
  <span class="keyword">val</span> dnode <span class="keyword">=</span> dec<span class="keyword">.</span>d1ec_node
  <span class="keyword">val+</span> D1ECval <span class="keyword">(</span>isrec<span class="keyword">,</span> valdecs<span class="keyword">)</span> <span class="keyword">=</span> dnode
<span class="keyword">in</span>
  <span class="keyword">if</span> isrec <span class="keyword">then</span> trans_clo1_v1aldeclst_rec <span class="keyword">(</span>valdecs<span class="keyword">,</span> Gamma<span class="keyword">)</span>
           <span class="keyword">else</span> trans_clo1_v1aldeclst <span class="keyword">(</span>valdecs<span class="keyword">,</span> Gamma<span class="keyword">)</span>
<span class="keyword">end</span>

<span class="comment">(* extern fun trans_clo1_v1aldeclst (valdecs: v1aldeclst, Gamma: ctx): (ctx, ctx) *)</span>
<span class="keyword">implement</span> trans_clo1_v1aldeclst <span class="keyword">(</span>valdecs<span class="keyword">,</span> Gamma<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> valdecs <span class="keyword">of</span>
  <span class="keyword">|</span> cons <span class="keyword">(</span>valdec<span class="keyword">,</span> valdecs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="keyword">val</span> <span class="keyword">(</span>gamma1<span class="keyword">,</span> esc1<span class="keyword">)</span> <span class="keyword">=</span> trans_clo1_v1aldec <span class="keyword">(</span>valdec<span class="keyword">,</span> Gamma<span class="keyword">)</span>
    <span class="keyword">val</span> <span class="keyword">(</span>gamma2<span class="keyword">,</span> esc2<span class="keyword">)</span> <span class="keyword">=</span> trans_clo1_v1aldeclst <span class="keyword">(</span>valdecs1<span class="keyword">,</span> gamma1<span class="keyword">)</span>
    <span class="keyword">val</span> esc <span class="keyword">=</span> symenv_merge <span class="keyword">(</span>esc1<span class="keyword">,</span> esc2<span class="keyword">)</span>
  <span class="keyword">in</span>
    <span class="keyword">(</span>gamma2<span class="keyword">,</span> esc<span class="keyword">)</span>
  <span class="keyword">end</span>
  <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>Gamma<span class="keyword">,</span> ctx_nil<span class="keyword">)</span>


<span class="comment">(* extern fun trans_clo1_v1aldeclst_rec (valdecs: v1aldeclst, Gamma: ctx): (ctx, ctx) *)</span>
<span class="keyword">implement</span> trans_clo1_v1aldeclst_rec <span class="keyword">(</span>valdecs<span class="keyword">,</span> Gamma<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> collect_var <span class="keyword">(</span>valdecs<span class="keyword">:</span> <span class="staexp">v1aldeclst</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp">ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">ctx</span> <span class="keyword">=</span> 
    <span class="keyword">case+</span> valdecs <span class="keyword">of</span>
    <span class="keyword">|</span> cons <span class="keyword">(</span>valdec<span class="keyword">,</span> valdecs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> v <span class="keyword">=</span> valdec<span class="keyword">.</span>v1aldec_var
      <span class="keyword">val</span> nam <span class="keyword">=</span> v<span class="keyword">.</span>v1ar_nam
      <span class="keyword">val</span> ctx <span class="keyword">=</span> symenv_insert <span class="keyword">(</span>ctx<span class="keyword">,</span> nam<span class="keyword">,</span> v<span class="keyword">)</span>
    <span class="keyword">in</span>
      collect_var <span class="keyword">(</span>valdecs1<span class="keyword">,</span> ctx<span class="keyword">)</span>
    <span class="keyword">end</span>
    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ctx
  
  <span class="keyword">val</span> Gamma1 <span class="keyword">=</span> collect_var <span class="keyword">(</span>valdecs<span class="keyword">,</span> Gamma<span class="keyword">)</span>
 
  <span class="comment">(* this esc is the env for the list of valdec *)</span>
  <span class="comment">(* These two Gamma1's should be same *)</span>
  <span class="keyword">val</span> <span class="keyword">(</span>Gamma1<span class="keyword">,</span> esc<span class="keyword">)</span> <span class="keyword">=</span> trans_clo1_v1aldeclst <span class="keyword">(</span>valdecs<span class="keyword">,</span> Gamma1<span class="keyword">)</span>
  <span class="keyword">val</span> esclst <span class="keyword">=</span> symenv_listize <span class="keyword">(</span>esc<span class="keyword">)</span>
  <span class="keyword">val</span> esclst <span class="keyword">=</span> list0_map_fun&lt;<span class="staexp"><span class="keyword">@(</span>symbol_t<span class="keyword">,</span> v1ar<span class="keyword">)</span></span><span class="keyword">&gt;&lt;</span><span class="staexp">v1ar</span><span class="keyword">&gt;</span> <span class="keyword">(</span>esclst<span class="keyword">,</span> <span class="keyword">lam</span> x <span class="keyword">=&gt;</span> x<span class="keyword">.</span>1<span class="keyword">)</span>

  <span class="keyword">fun</span> closure_set_env <span class="keyword">(</span>e1xp<span class="keyword">:</span> <span class="staexp">e1xp</span><span class="keyword">,</span> vs<span class="keyword">:</span> <span class="staexp">v1arlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">case+</span>  e1xp<span class="keyword">.</span>e1xp_node <span class="keyword">of</span>
    <span class="keyword">|</span> E1XPann <span class="keyword">(</span>e1<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> closure_set_env <span class="keyword">(</span>e1<span class="keyword">,</span> vs<span class="keyword">)</span>
    <span class="keyword">|</span> E1XPfix <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> env_ref<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">!</span>env_ref := vs
    <span class="keyword">|</span> E1XPlam <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">,</span> env_ref<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">!</span>env_ref := vs
    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>

  <span class="comment">(* All the v1aldec_rec in the list have the same env. *)</span>
  <span class="keyword">val</span> _ <span class="keyword">=</span> list0_map_cloref&lt;<span class="staexp">v1aldec</span><span class="keyword">&gt;&lt;</span><span class="staexp">int</span><span class="keyword">&gt;</span>  <span class="comment">// todo use void instead of int
</span>    <span class="keyword">(</span>valdecs<span class="keyword">,</span> <span class="keyword">lam</span> valdec <span class="keyword">=&gt;</span> <span class="keyword">let</span> <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> closure_set_env <span class="keyword">(</span>valdec<span class="keyword">.</span>v1aldec_def<span class="keyword">,</span> esclst<span class="keyword">)</span> <span class="keyword">in</span> 0 <span class="keyword">end</span><span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">(</span>Gamma1<span class="keyword">,</span> esc<span class="keyword">)</span>
<span class="keyword">end</span>

<span class="comment">(* extern fun trans_clo1_v1aldec (valdec: v1aldec, Gamma: ctx): (ctx, ctx) *)</span>
<span class="keyword">implement</span> trans_clo1_v1aldec <span class="keyword">(</span>valdec<span class="keyword">,</span> Gamma<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> v <span class="keyword">=</span> valdec<span class="keyword">.</span>v1aldec_var
  <span class="keyword">val</span> e <span class="keyword">=</span> valdec<span class="keyword">.</span>v1aldec_def

  <span class="keyword">val</span> esc <span class="keyword">=</span> trans_clo1_e1xp <span class="keyword">(</span>e<span class="keyword">,</span> Gamma<span class="keyword">)</span>

  <span class="keyword">val</span> nam <span class="keyword">=</span> v<span class="keyword">.</span>v1ar_nam
  <span class="keyword">val</span> gamma <span class="keyword">=</span> symenv_insert <span class="keyword">(</span>Gamma<span class="keyword">,</span> nam<span class="keyword">,</span> v<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">(</span>gamma<span class="keyword">,</span> esc<span class="keyword">)</span>
<span class="keyword">end</span>

<span class="comment">(*
// (* *********** ************** *************** *)
// extern fun trans_clo2_e1xp_fix (f: v1ar, args: v1arlst, body: e1xp, 
//   esc: v1arlst, Gamma: ctx, env: v1arlst): e1xp_node
// 
// extern fun trans_clo2_e1xp_lam (args: v1arlst, body: e1xp, 
//   esc: v1arlst, Gamma: ctx, env: v1arlst): e1xp_node
// 
// extern fun trans_clo2_d1eclst (decs: d1eclst, 
//   Gamma: ctx, env: v1arlst): (ctx(*new gamma*), d1eclst)
// extern fun trans_clo2_d1ec (dec: d1ec, 
//   Gamma: ctx, env: v1arlst): (ctx, d1ec)
// 
// extern fun trans_clo2_v1aldeclst (valdecs: v1aldeclst, 
//   Gamma: ctx, env: v1arlst): (ctx, v1aldeclst)
// extern fun trans_clo2_v1aldeclst_rec (valdecs: v1aldeclst, 
//   Gamma: ctx, env: v1arlst): (ctx, v1aldeclst)
// 
// extern fun trans_clo2_v1aldec (valdec: v1aldec, 
//   Gamma: ctx, env: v1arlst): (ctx, v1aldec)
// extern fun trans_clo2_v1aldec_rec (valdec: v1aldec, 
//   Gamma: ctx, env: v1arlst): v1aldec
// 
// extern fun trans_clo2_e1xplst (exps: e1xplst,
//   Gamma: ctx, env: v1arlst): e1xplst
// 
// (* var list for the closure environment *)
// (* Gamma: from function arguments and var declaration
//    env: the closure info
// *)
// (* reconstruct the tree, semantically same v1ar's are actually the same. *)
// fun trans_clo2_e1xp (exp: e1xp, Gamma: ctx, env: v1arlst): e1xp = let
//   val loc = exp.e1xp_loc
//   val node = exp.e1xp_node
//   val typ = exp.e1xp_typ
// in
//   case+ node of
//   | E1XPann (e, t) =&gt; let
//     val e = trans_clo2_e1xp (e, Gamma, env)
//     val exp_node = E1XPann (e, e.e1xp_typ)
//   in
//     e1xp_make (loc, exp_node, e.e1xp_typ)
//   end
//   | E1XPapp (f, args) =&gt; let
//     val f = trans_clo2_e1xp (f, Gamma, env)
//     val args = trans_clo2_e1xp (args, Gamma, env)
//     val exp_node = E1XPapp (f, args)
//   in
//     e1xp_make (loc, exp_node, typ)
//   end
//   | E1XPbool _ =&gt; e1xp_make (loc, node, typ)
//   | E1XPfix (f, args, body, ref_esc) =&gt; 
//     e1xp_make (loc, trans_clo2_e1xp_fix (f, args, body, !ref_esc, Gamma, env), typ)
//   | E1XPif (e_if, e_then, eo_else) =&gt; let
//     val e_if = trans_clo2_e1xp (e_if, Gamma, env)
//     val e_then = trans_clo2_e1xp (e_then, Gamma, env)
//     val eo_else = (case+ eo_else of
//                  | Some0 e_else =&gt; Some0 (trans_clo2_e1xp (e_else, Gamma, env))
//                  | None0 () =&gt; None0 ()
//                  ): (option0 e1xp)
//     val exp_node = E1XPif (e_if, e_then, eo_else)
//   in
//     e1xp_make (loc, exp_node, typ)
//   end
//   | E1XPint _ =&gt; e1xp_make (loc, node, typ)
//   | E1XPlam (args, body, ref_esc) =&gt;
//     e1xp_make (loc, trans_clo2_e1xp_lam (args, body, !ref_esc, Gamma, env), typ)
//   | E1XPlet (decs, e) =&gt; let
//     val (gamma, decs1) = trans_clo2_d1eclst (decs, Gamma, env)
//     val e1 = trans_clo2_e1xp (e, gamma, env)
//   in
//     e1xp_make (loc, E1XPlet (decs1, e1), typ)
//   end
//   | E1XPopr (opr, es) =&gt;
//       e1xp_make (loc, 
//                  E1XPopr (opr, trans_clo2_e1xplst (es, Gamma, env)), 
//                  typ)
//   | E1XPproj (e, i) =&gt; let
//     val e = trans_clo2_e1xp (e, Gamma, env)
//     val exp_node = E1XPproj (e, i)
//   in
//     e1xp_make (loc, exp_node, typ)
//   end
//   | E1XPstr _ =&gt; e1xp_make (loc, node, typ)
//   | E1XPtup es =&gt; let
//     val es = trans_clo2_e1xplst (es, Gamma, env)
//   in
//     e1xp_make (loc, E1XPtup es, typ)
//   end
//   | E1XPvar v =&gt; let  // todo is this necessary?
//     val vo1 = symenv_lookup (Gamma, v.v1ar_nam)
//   in
//     case+ vo1 of
//     | Some0 v1 =&gt; e1xp_make (loc, E1XPvar v1, typ)
//     | None0 () =&gt; let
//       val vo2 = list0_find_cloref&lt;v1ar&gt; (env, lam x =&gt; x.v1ar_nam = v.v1ar_nam)
//     in
//       case+ vo2 of
//       | Some0 v2 =&gt; e1xp_make (loc, E1XPvar v2, typ)
//       | None0 () =&gt; ETRACE_MSG_OPR ("trans_clo2_e1xp var not found\n", 
//           ETRACE_LEVEL_ERROR, abort (ERRORCODE_FORBIDDEN))
//     end
//   end
//   | E1XPfixclo _ =&gt; ETRACE_MSG_OPR ("trans_clo2_e1xp E1XPfixclo is found\n", 
//           ETRACE_LEVEL_ERROR, abort (ERRORCODE_FORBIDDEN))
//   | E1XPlamclo _ =&gt; ETRACE_MSG_OPR ("trans_clo2_e1xp E1XPlamclo is found\n", 
//           ETRACE_LEVEL_ERROR, abort (ERRORCODE_FORBIDDEN))
// end
// 
// (* extern fun trans_clo2_e1xp_fix (f: v1ar, args: v1arlst, body: e1xp, 
//   esc: v1arlst, Gamma: ctx, env: v1arlst, loc: loc): e1xp
// *)
// implement trans_clo2_e1xp_fix (f, args, body, esc, Gamma, env) = let
//   // put f into env
//   val env' = f :: env
//   (* find the v1ar in the Gamma or env based on name *)
//   fun helper (v: v1ar):&lt;cloref1&gt; v1ar = let
//     val vopt1 = symenv_lookup (Gamma, v.v1ar_nam)
//   in
//     case+ vopt1 of
//     | Some0 v1 =&gt; v1
//     | None0 () =&gt; let
//       val vopt2 = list0_find_cloref&lt;v1ar&gt; (env', lam x =&gt; x.v1ar_nam = v.v1ar_nam)
//     in
//       case+ vopt2 of
//       | Some0 v2 =&gt; v2
//       | None0 () =&gt; ETRACE_MSG_OPR ("trans_clo1_e1xp_fix var not found\n", ETRACE_LEVEL_ERROR,
//                   abort (ERRORCODE_FORBIDDEN))
//     end
//   end
// 
//   val env1 = list0_map_cloref&lt;v1ar&gt;&lt;v1ar&gt; (esc, helper)  // f maybe inside env1
// 
//   val Gamma1 = symenv_inserts (ctx_nil, 
//     list0_map_fun&lt;v1ar&gt;&lt;(symbol_t, v1ar)&gt; (args, lam x =&gt; (x.v1ar_nam, x)))
// 
//   val body_exp = trans_clo2_e1xp (body, Gamma1, env1)
// 
//   val exp_node = E1XPfixclo (f, args, body_exp, env1)
// in
//   exp_node
// end
// 
// (* extern fun trans_clo2_e1xp_lam (args: v1arlst, body: e1xp, 
//   esc: v1arlst, Gamma: ctx, env: v1arlst, loc: loc): e1xp
// *)
// implement trans_clo2_e1xp_lam (args, body, esc, Gamma, env) = let
//   (* find the v1ar in the Gamma or env based on name *)
//   fun helper (v: v1ar):&lt;cloref1&gt; v1ar = let
//     val vopt1 = symenv_lookup (Gamma, v.v1ar_nam)
//   in
//     case+ vopt1 of
//     | Some0 v1 =&gt; v1
//     | None0 () =&gt; let
//       val vopt2 = list0_find_cloref&lt;v1ar&gt; (env, lam x =&gt; x.v1ar_nam = v.v1ar_nam)
//     in
//       case+ vopt2 of
//       | Some0 v2 =&gt; v2
//       | None0 () =&gt; ETRACE_MSG_OPR ("trans_clo1_e1xp_fix var not found\n", ETRACE_LEVEL_ERROR,
//                   abort (ERRORCODE_FORBIDDEN))
//     end
//   end
// 
//   val env1 = list0_map_cloref&lt;v1ar&gt;&lt;v1ar&gt; (esc, helper)
// 
//   val Gamma1 = symenv_inserts (ctx_nil, 
//     list0_map_fun&lt;v1ar&gt;&lt;(symbol_t, v1ar)&gt; (args, lam x =&gt; (x.v1ar_nam, x)))
// 
//   val body_exp = trans_clo2_e1xp (body, Gamma1, env1)
// 
//   val exp_node = E1XPlamclo (args, body_exp, env1)
// in
//   exp_node
// end
// 
//   
// (* extern fun trans_clo2_e1xplst (exps: e1xplst,
//   Gamma: ctx, env: v1arlst): e1xplst *)
// implement trans_clo2_e1xplst (exps, Gamma, env) =
//   case+ exps of
//   | cons (exp, exps1) =&gt;
//     cons (trans_clo2_e1xp (exp, Gamma, env), trans_clo2_e1xplst (exps1, Gamma, env))
//   | nil () =&gt; nil ()
// 
// (* extern fun trans_clo2_d1eclst (decs: d1eclst, 
//   Gamma: ctx, env: v1arlst): (ctx(*new gamma*), d1eclst) *)
// implement trans_clo2_d1eclst (decs, Gamma, env) =
//   case+ decs of
//   | cons (dec, decs1) =&gt; let
//     val (gamma1, dec') = trans_clo2_d1ec (dec, Gamma, env)
//     val (gamma2, decs1') = trans_clo2_d1eclst (decs1, gamma1, env)
//   in
//     (gamma2, cons (dec', decs1'))
//   end
//   | nil () =&gt; (Gamma, nil ())
// 
// 
// (* extern fun trans_clo2_d1ec (dec: d1ec, 
//   Gamma: ctx, env: v1arlst): (ctx, d1ec) *)
// implement trans_clo2_d1ec (dec, Gamma, env) = let
//   val loc = dec.d1ec_loc
//   val dnode = dec.d1ec_node
//   val+ D1ECval (isrec, valdecs) = dnode
//   val (gamma, valdecs1) = 
//     if isrec then trans_clo2_v1aldeclst_rec (valdecs, Gamma, env)
//              else trans_clo2_v1aldeclst (valdecs, Gamma, env)
// in
//   (gamma, d1ec_make_val (loc, isrec, valdecs1))
// end
// 
// (* extern fun trans_clo2_v1aldeclst (valdecs: v1aldeclst, 
//   Gamma: ctx, env: v1arlst): (ctx, v1aldeclst) *)
// implement trans_clo2_v1aldeclst (valdecs, Gamma, env) =
//   case+ valdecs of
//   | cons (valdec, valdecs1) =&gt; let
//     val (gamma1, valdec') = trans_clo2_v1aldec (valdec, Gamma, env)
//     val (gamma2, valdecs1') = trans_clo2_v1aldeclst (valdecs1, gamma1, env)
//   in
//     (gamma2, cons (valdec', valdecs1'))
//   end
//   | nil () =&gt; (Gamma, nil ())
// 
// (* extern fun trans_clo2_v1aldeclst_rec (valdecs: v1aldeclst, 
//   Gamma: ctx, env: v1arlst): (ctx, v1aldeclst) *)
// implement trans_clo2_v1aldeclst_rec (valdecs, Gamma, env) = let
//   val vars = list0_map_fun&lt;v1aldec&gt;&lt;(symbol_t, v1ar)&gt; (
//     valdecs, lam x =&gt; (x.v1aldec_var.v1ar_nam, x.v1aldec_var))
// 
//   val gamma = symenv_inserts (Gamma, vars)
// 
//   fun trans_clo2_v1aldeclst_rec_impl (valdecs: v1aldeclst, 
//     Gamma: ctx, env: v1arlst):&lt;cloref1&gt; v1aldeclst =
//     case+ valdecs of
//     | cons (valdec, valdecs1) =&gt; let
//       val valdec' = trans_clo2_v1aldec_rec (valdec, gamma, env)
//       val valdecs1' = trans_clo2_v1aldeclst_rec_impl (valdecs1, gamma, env)
//     in
//       cons (valdec', valdecs1')
//     end
//     | nil () =&gt; nil ()
// 
//   val ret = trans_clo2_v1aldeclst_rec_impl (valdecs, gamma, env) 
// in
//   (gamma, ret)  // todo is this correct?
// end
// 
// (* extern fun trans_clo2_v1aldec (valdec: v1aldec, 
//   Gamma: ctx, env: v1arlst): (ctx, v1aldec) *)
// implement trans_clo2_v1aldec (valdec, Gamma, env) = let
//   val loc = valdec.v1aldec_loc
//   val v = valdec.v1aldec_var
//   val def = valdec.v1aldec_def
// 
//   val nam = v.v1ar_nam
//   val gamma = symenv_insert (Gamma, nam, v)
//   val def' = trans_clo2_e1xp (def, gamma, env)
// 
//   val () = !(v.v1ar_def) := (Some0 def')
// in
//   (gamma, v1aldec_make (loc, v, def'))
// end
// 
// (* extern fun trans_clo2_v1aldec_rec (valdec: v1aldec, 
//   Gamma: ctx, env: v1arlst): v1aldec *)
// implement trans_clo2_v1aldec_rec (valdec, Gamma, env) = let
//   val loc = valdec.v1aldec_loc
//   val v = valdec.v1aldec_var
//   val def = valdec.v1aldec_def
// 
//   val def' = trans_clo2_e1xp (def, Gamma, env)
// 
//   val () = !(v.v1ar_def) := (Some0 def')
// in
//   v1aldec_make (loc, v, def')
// end
// 
*)</span>

<span class="keyword">implement</span> trans_closure <span class="keyword">(</span>e1xp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> ctx <span class="keyword">=</span> trans_clo1_e1xp <span class="keyword">(</span>e1xp<span class="keyword">,</span> ctx_nil<span class="keyword">)</span>
  <span class="keyword">val</span> ctx <span class="keyword">=</span> symenv_listize <span class="keyword">(</span>ctx<span class="keyword">)</span>
   <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> ctx <span class="keyword">of</span>
            <span class="keyword">|</span> cons <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> fprint <span class="keyword">(</span>stderr_ref<span class="keyword">,</span> "000000000000000000000000000000000\n"<span class="keyword">)</span>
            <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> fprint <span class="keyword">(</span>stderr_ref<span class="keyword">,</span> "111111111111111111111111111111\n"<span class="keyword">)</span>
  <span class="comment">// val e = trans_clo2_e1xp (e1xp, ctx_nil, nil)  // todo remove
</span><span class="keyword">in</span>
  e1xp
<span class="keyword">end</span>












































</pre>
</body>
</html>
