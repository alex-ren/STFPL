<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    .atsyntax {color:#E80000;background-color:#E0E0E0}
    .atsyntax span.comment {color:#787878;font-style:italic}
    .atsyntax span.extern  {color:#A52A2A}
    .atsyntax span.keyword {color:#000000;font-weight:bold}
    .atsyntax span.neuexp  {color:#800080}
    .atsyntax span.staexp  {color:#0000FF}
    .atsyntax span.dynexp  {color:#E80000}
    .atsyntax span.prfexp  {color:#009000}
    .atsyntax span.stacstdec  {text-decoration:none}
    .atsyntax span.stacstuse  {color:#0000CF;text-decoration:underline}
    .atsyntax span.dyncstdec  {text-decoration:none}
    .atsyntax span.dyncstimp  {color:#B80000;text-decoration:underline}
    .atsyntax span.dyncstuse  {color:#B80000;text-decoration:underline}
    body {color:#E80000;background-color:#E0E0E0}
  </style>
</head>
<body>
<pre class="atsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                              Hongwei Xi                             *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS - Unleashing the Potential of Types!
**
** Copyright (C) 2002-2010 Hongwei Xi, Boston University
**
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the  terms of the  GNU General Public License as published by the Free
** Software Foundation; either version 2.1, or (at your option) any later
** version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
**
** A functional map implementation based on AVL trees
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: March, 2010 // based on a version done in October, 2008
**
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">//
</span><span class="comment">// License: LGPL 3.0 (available at http://www.gnu.org/licenses/lgpl.txt)
</span><span class="comment">//
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">#define</span> <span class="neuexp">ATS_DYNLOADFLAG 0</span> <span class="comment">// no dynamic loading at run-time
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">"libats/SATS/funmap_avltree.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">//
</span><span class="comment">// a specialized version can be implemented on the spot
</span><span class="comment">//
</span><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">}</span> compare_key_key <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> cmp <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">//
</span><span class="comment">// HX-2010-03-24: this seems to work best!
</span><span class="comment">//
</span><span class="keyword">#define</span> <span class="neuexp">HTDF 1</span> <span class="comment">// max height difference
</span><span class="keyword">#define</span> <span class="neuexp">HTDF1 <span class="keyword">%(</span>HTDF+1<span class="keyword">)</span></span>
<span class="keyword">#define</span> <span class="neuexp">HTDF_1 <span class="keyword">%(</span>HTDF-1<span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">datatype</span> <span class="staexp"><a name="2180"><span class="stacstdec">avltree <span class="keyword">(</span>
  key<span class="keyword">:</span>t@ype<span class="keyword">,</span> itm<span class="keyword">:</span>t@ype+<span class="keyword">,</span> int<span class="comment">(*height*)</span>
<span class="keyword">)</span></span></a></span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat</span> <span class="keyword">|</span> <span class="staexp">hl &lt;= hr+HTDF</span><span class="keyword">;</span> <span class="staexp">hr &lt;= hl+HTDF</span><span class="keyword">}</span>
    B <span class="staexp"><span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> 1+max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span><span class="keyword">)</span></span> <span class="keyword">of</span>
      <span class="staexp"><span class="keyword">(</span>int <span class="keyword">(</span>1+max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> key<span class="keyword">,</span> itm<span class="keyword">,</span> avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hl<span class="keyword">)</span><span class="keyword">,</span> avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hr<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> E <span class="staexp"><span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> 0<span class="keyword">)</span></span>
<span class="comment">// end of [datatype avltree]
</span>
<span class="keyword">typedef</span> <span class="staexp"><a name="2457"><span class="stacstdec">avltree_inc <span class="keyword">(</span>key<span class="keyword">:</span>t@ype<span class="keyword">,</span> itm<span class="keyword">:</span>t@ype<span class="keyword">,</span> h<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">[</span>h1<span class="keyword">:</span>nat <span class="keyword">|</span> h &lt;= h1<span class="keyword">;</span> h1 &lt;= h+1<span class="keyword">]</span> avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h1<span class="keyword">)</span></span></a></span>
<span class="comment">// end of [avltree_inc]
</span>
<span class="keyword">typedef</span> <span class="staexp"><a name="2589"><span class="stacstdec">avltree_dec <span class="keyword">(</span>key<span class="keyword">:</span>t@ype<span class="keyword">,</span> itm<span class="keyword">:</span>t@ype<span class="keyword">,</span> h<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">[</span>h1<span class="keyword">:</span>nat <span class="keyword">|</span> h1 &lt;= h<span class="keyword">;</span> h &lt;= h1+1<span class="keyword">]</span> avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h1<span class="keyword">)</span></span></a></span>
<span class="comment">// end of [avltree_dec]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">assume</span>
<span class="staexp">map_t0ype_type <span class="keyword">(</span>
  key<span class="keyword">:</span>t@ype<span class="keyword">,</span> itm<span class="keyword">:</span>t@ype
<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">[</span>h<span class="keyword">:</span>nat<span class="keyword">]</span> avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="keyword">}</span> funmap_make_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> E <span class="keyword">(</span><span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="keyword">}</span>
funmap_is_nil <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> t <span class="keyword">of</span> <span class="keyword">|</span> B _ <span class="keyword">=&gt;</span> false <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
<span class="comment">// end of [funmap_is_nil]
</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="keyword">}</span>
funmap_isnot_nil <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> t <span class="keyword">of</span> <span class="keyword">|</span> B _ <span class="keyword">=&gt;</span> true <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> false
<span class="comment">// end of [funmap_isnot_nil]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_size <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">=</span> size <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> size <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">size_t</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> _<span class="comment">(*key*)</span><span class="keyword">,</span> _<span class="comment">(*itm*)</span><span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>size_of_int1<span class="keyword">)</span>1 + size <span class="keyword">(</span>tl<span class="keyword">)</span> + size <span class="keyword">(</span>tr<span class="keyword">)</span>
    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0
  <span class="keyword">end</span> <span class="comment">// end of [size]
</span><span class="keyword">}</span> <span class="comment">// end of [funmap_size]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">macdef</span> <span class="neuexp">avltree_height <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> <span class="keyword">,(</span>t<span class="keyword">)</span> <span class="keyword">of</span> B <span class="keyword">(</span>h<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> h <span class="keyword">|</span> E _ <span class="keyword">=&gt;</span> 0</span>
<span class="comment">// end of [avltree_height]
</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_height <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">=</span> avltree_height <span class="keyword">(</span>t<span class="keyword">)</span>
<span class="comment">// end of [funmap_height]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_search
  <span class="keyword">(</span>t<span class="keyword">,</span> k0<span class="keyword">,</span> cmp<span class="keyword">,</span> res<span class="keyword">)</span> <span class="keyword">=</span> search <span class="keyword">(</span>t<span class="keyword">,</span> res<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> search <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
      t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>itm? &gt;&gt; opt <span class="keyword">(</span>itm<span class="keyword">,</span> b<span class="keyword">)</span></span>
    <span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">#[</span>b<span class="keyword">:</span>bool<span class="keyword">]</span> bool b</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> sgn <span class="keyword">=</span> compare_key_key <span class="keyword">(</span>k0<span class="keyword">,</span> k<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">case+</span> 0 <span class="keyword">of</span>
        <span class="keyword">|</span> _ <span class="keyword">when</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">=&gt;</span> search <span class="keyword">(</span>tl<span class="keyword">,</span> res<span class="keyword">)</span>
        <span class="keyword">|</span> _ <span class="keyword">when</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">=&gt;</span> search <span class="keyword">(</span>tr<span class="keyword">,</span> res<span class="keyword">)</span>
        <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> res := x<span class="keyword">;</span> <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> opt_some <span class="staexp"><span class="keyword">{</span>itm<span class="keyword">}</span></span> <span class="keyword">(</span>res<span class="keyword">)</span></span> <span class="keyword">in</span> true
          <span class="keyword">end</span> <span class="comment">// end of [_]
</span>      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> opt_none <span class="staexp"><span class="keyword">{</span>itm<span class="keyword">}</span></span> <span class="keyword">(</span>res<span class="keyword">)</span></span> <span class="keyword">in</span> false
      <span class="keyword">end</span> <span class="comment">// end of [E]
</span>  <span class="keyword">end</span> <span class="comment">// end of [search]
</span><span class="keyword">}</span> <span class="comment">// end of [funmap_search]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
** left rotation for restoring height invariant
*)</span>
<span class="keyword">fn</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
avltree_lrotate <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat <span class="keyword">|</span> hl+HTDF1 == hr<span class="keyword">}</span></span> <span class="keyword">(</span>
    k<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">itm</span>
  <span class="keyword">,</span> hl <span class="keyword">:</span> <span class="staexp">int hl</span>
  <span class="keyword">,</span> tl<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hl<span class="keyword">)</span></span>
  <span class="keyword">,</span> hr <span class="keyword">:</span> <span class="staexp">int hr</span>
  <span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hr<span class="keyword">)</span></span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp">avltree_inc <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hr<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val+</span> B <span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>hrl<span class="keyword">,</span>hrr<span class="keyword">}</span></span> <span class="keyword">(</span>_<span class="comment">(*hr*)</span><span class="keyword">,</span> kr<span class="keyword">,</span> xr<span class="keyword">,</span> trl<span class="keyword">,</span> trr<span class="keyword">)</span> <span class="keyword">=</span> tr
  <span class="keyword">val</span> hrl <span class="keyword">=</span> avltree_height trl <span class="keyword">:</span> <span class="staexp">int hrl</span>
  <span class="keyword">and</span> hrr <span class="keyword">=</span> avltree_height trr <span class="keyword">:</span> <span class="staexp">int hrr</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> hrl &lt;= hrr+HTDF_1 <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="keyword">val</span> hrl1 <span class="keyword">=</span> hrl + 1
  <span class="keyword">in</span>
    B <span class="keyword">(</span>1+max<span class="keyword">(</span>hrl1<span class="keyword">,</span>hrr<span class="keyword">)</span><span class="keyword">,</span> kr<span class="keyword">,</span> xr<span class="keyword">,</span> B <span class="keyword">(</span>hrl1<span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> trl<span class="keyword">)</span><span class="keyword">,</span> trr<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span> <span class="comment">// [hrl=hrr+2]: deep rotation
</span>    <span class="keyword">val+</span> B <span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>hrll<span class="keyword">,</span>hrlr<span class="keyword">}</span></span> <span class="keyword">(</span>_<span class="comment">(*hrl*)</span><span class="keyword">,</span> krl<span class="keyword">,</span> xrl<span class="keyword">,</span> trll<span class="keyword">,</span> trlr<span class="keyword">)</span> <span class="keyword">=</span> trl
    <span class="keyword">val</span> hrll <span class="keyword">=</span> avltree_height trll <span class="keyword">:</span> <span class="staexp">int hrll</span>
    <span class="keyword">val</span> hrlr <span class="keyword">=</span> avltree_height trlr <span class="keyword">:</span> <span class="staexp">int hrlr</span>
  <span class="keyword">in</span>
    B <span class="keyword">(</span>hr<span class="keyword">,</span> krl<span class="keyword">,</span> xrl<span class="keyword">,</span> B <span class="keyword">(</span>1+max<span class="keyword">(</span>hl<span class="keyword">,</span>hrll<span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> trll<span class="keyword">)</span><span class="keyword">,</span> B <span class="keyword">(</span>1+max<span class="keyword">(</span>hrlr<span class="keyword">,</span>hrr<span class="keyword">)</span><span class="keyword">,</span> kr<span class="keyword">,</span> xr<span class="keyword">,</span> trlr<span class="keyword">,</span> trr<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">// end of [avltree_lrotate]
</span>
<span class="comment">(*
** right rotation for restoring height invariant
*)</span>
<span class="keyword">fn</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
avltree_rrotate <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat <span class="keyword">|</span> hl == hr+HTDF1<span class="keyword">}</span></span> <span class="keyword">(</span>
    k<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">itm</span>
  <span class="keyword">,</span> hl<span class="keyword">:</span> <span class="staexp">int hl</span>
  <span class="keyword">,</span> tl<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hl<span class="keyword">)</span></span>
  <span class="keyword">,</span> hr<span class="keyword">:</span> <span class="staexp">int hr</span>
  <span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hr<span class="keyword">)</span></span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp">avltree_inc <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hl<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val+</span> B <span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>hll<span class="keyword">,</span> hlr<span class="keyword">}</span></span> <span class="keyword">(</span>_<span class="comment">(*hl*)</span><span class="keyword">,</span> kl<span class="keyword">,</span> xl<span class="keyword">,</span> tll<span class="keyword">,</span> tlr<span class="keyword">)</span> <span class="keyword">=</span> tl
  <span class="keyword">val</span> hll <span class="keyword">=</span> avltree_height tll <span class="keyword">:</span> <span class="staexp">int hll</span>
  <span class="keyword">and</span> hlr <span class="keyword">=</span> avltree_height tlr <span class="keyword">:</span> <span class="staexp">int hlr</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> hll+HTDF_1 &gt;= hlr <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="keyword">val</span> hlr1 <span class="keyword">=</span> hlr + 1
  <span class="keyword">in</span>
    B <span class="keyword">(</span>1+max<span class="keyword">(</span>hll<span class="keyword">,</span>hlr1<span class="keyword">)</span><span class="keyword">,</span> kl<span class="keyword">,</span> xl<span class="keyword">,</span> tll<span class="keyword">,</span> B <span class="keyword">(</span>hlr1<span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tlr<span class="keyword">,</span> tr<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="keyword">val+</span> B <span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>hlrl<span class="keyword">,</span>hlrr<span class="keyword">}</span></span> <span class="keyword">(</span>_<span class="comment">(*hlr*)</span><span class="keyword">,</span> klr<span class="keyword">,</span> xlr<span class="keyword">,</span> tlrl<span class="keyword">,</span> tlrr<span class="keyword">)</span> <span class="keyword">=</span> tlr
    <span class="keyword">val</span> hlrl <span class="keyword">=</span> avltree_height tlrl <span class="keyword">:</span> <span class="staexp">int hlrl</span>
    <span class="keyword">val</span> hlrr <span class="keyword">=</span> avltree_height tlrr <span class="keyword">:</span> <span class="staexp">int hlrr</span>
  <span class="keyword">in</span>
    B <span class="keyword">(</span>hl<span class="keyword">,</span> klr<span class="keyword">,</span> xlr<span class="keyword">,</span> B <span class="keyword">(</span>1+max<span class="keyword">(</span>hll<span class="keyword">,</span>hlrl<span class="keyword">)</span><span class="keyword">,</span> kl<span class="keyword">,</span> xl<span class="keyword">,</span> tll<span class="keyword">,</span> tlrl<span class="keyword">)</span><span class="keyword">,</span> B <span class="keyword">(</span>1+max<span class="keyword">(</span>hlrr<span class="keyword">,</span>hr<span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tlrr<span class="keyword">,</span> tr<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">// end of [avltree_rrotate]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_insert
  <span class="keyword">(</span>m<span class="keyword">,</span> k0<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> res <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> insert <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
      t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>bool? &gt;&gt; bool</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">avltree_inc <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">}</span></span> <span class="keyword">(</span>h<span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> sgn <span class="keyword">=</span> compare_key_key <span class="keyword">(</span>k0<span class="keyword">,</span> k<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">hl<span class="keyword">:</span>int</span><span class="keyword">]</span> tl <span class="keyword">=</span> insert <span class="keyword">(</span>tl<span class="keyword">,</span> res<span class="keyword">)</span>
          <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hl</span>
          <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hr</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> hl - hr &lt;= HTDF <span class="keyword">then</span> <span class="keyword">begin</span>
            B <span class="keyword">(</span>1+max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl = hr+HTDF1
</span>            avltree_rrotate <span class="keyword">(</span>k<span class="keyword">,</span> x<span class="keyword">,</span> hl<span class="keyword">,</span> tl<span class="keyword">,</span> hr<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">hr<span class="keyword">:</span>int</span><span class="keyword">]</span> tr <span class="keyword">=</span> insert <span class="keyword">(</span>tr<span class="keyword">,</span> res<span class="keyword">)</span>
          <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hl</span>
          <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hr</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> hr - hl &lt;= HTDF <span class="keyword">then</span> <span class="keyword">begin</span>
            B <span class="keyword">(</span>1+max<span class="keyword">(</span>hl<span class="keyword">,</span> hr<span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl+HTDF1 = hr
</span>            avltree_lrotate <span class="keyword">(</span>k<span class="keyword">,</span> x<span class="keyword">,</span> hl<span class="keyword">,</span> tl<span class="keyword">,</span> hr<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span> <span class="comment">(* [k0] already exists *)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> res := true <span class="keyword">in</span> B <span class="keyword">(</span>h<span class="keyword">,</span> k<span class="keyword">,</span> x0<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span> <span class="comment">(* [k0] is not in [m] *)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> res := false <span class="keyword">in</span> B <span class="keyword">(</span>1<span class="keyword">,</span> k0<span class="keyword">,</span> x0<span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [E]
</span>  <span class="keyword">end</span> <span class="comment">// end of [insert]
</span>  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">bool</span> <span class="comment">// uninitialized
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> m := insert <span class="keyword">(</span>m<span class="keyword">,</span> res<span class="keyword">)</span>
<span class="keyword">}</span> <span class="comment">// end of [funmap_insert]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_insert_clo
  <span class="keyword">(</span>m<span class="keyword">,</span> k0<span class="keyword">,</span> x0<span class="keyword">,</span> f<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> insert <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span><span class="keyword">(</span>itm<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>clo<span class="keyword">&gt;</span> itm</span><span class="keyword">)</span>
    <span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">avltree_inc <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">}</span></span> <span class="keyword">(</span>h<span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> sgn <span class="keyword">=</span> compare_key_key <span class="keyword">(</span>k0<span class="keyword">,</span> k<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">hl<span class="keyword">:</span>int</span><span class="keyword">]</span> tl <span class="keyword">=</span> insert <span class="keyword">(</span>tl<span class="keyword">,</span> f<span class="keyword">)</span>
          <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hl</span>
          <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hr</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> hl - hr &lt;= HTDF <span class="keyword">then</span> <span class="keyword">begin</span>
            B <span class="keyword">(</span>1+max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl = hr+HTDF1
</span>            avltree_rrotate <span class="keyword">(</span>k<span class="keyword">,</span> x<span class="keyword">,</span> hl<span class="keyword">,</span> tl<span class="keyword">,</span> hr<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">hr<span class="keyword">:</span>int</span><span class="keyword">]</span> tr <span class="keyword">=</span> insert <span class="keyword">(</span>tr<span class="keyword">,</span> f<span class="keyword">)</span>
          <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hl</span>
          <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hr</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> hr - hl &lt;= HTDF <span class="keyword">then</span> <span class="keyword">begin</span>
            B <span class="keyword">(</span>1+max<span class="keyword">(</span>hl<span class="keyword">,</span> hr<span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl+HTDF1 = hr
</span>            avltree_lrotate <span class="keyword">(</span>k<span class="keyword">,</span> x<span class="keyword">,</span> hl<span class="keyword">,</span> tl<span class="keyword">,</span> hr<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">(* sgn = 0: item already exists *)</span>
          B <span class="keyword">(</span>h<span class="keyword">,</span> k<span class="keyword">,</span> f <span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">)</span><span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        B <span class="keyword">(</span>1<span class="keyword">,</span> k0<span class="keyword">,</span> x0<span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [E]
</span>  <span class="keyword">end</span> <span class="comment">// end of [insert]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> m := insert <span class="keyword">(</span>m<span class="keyword">,</span> f<span class="keyword">)</span>
<span class="keyword">}</span> <span class="comment">// end of [funmap_insert_clo]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
avltree_takeout_min <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
    t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span>
  <span class="keyword">,</span> k0<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>key? &gt;&gt; key</span>
  <span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>itm? &gt;&gt; itm</span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp">avltree_dec <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val+</span> B <span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">}</span></span> <span class="keyword">(</span>_<span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=</span> t
<span class="keyword">in</span>
  <span class="keyword">case+</span> tl <span class="keyword">of</span>
  <span class="keyword">|</span> B _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">hl<span class="keyword">:</span>int</span><span class="keyword">]</span> tl <span class="keyword">=</span> avltree_takeout_min&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="keyword">(</span>tl<span class="keyword">,</span> k0<span class="keyword">,</span> x0<span class="keyword">)</span>
      <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hl</span>
      <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hr</span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> hr - hl &lt;= HTDF <span class="keyword">then</span> <span class="keyword">begin</span>
        B <span class="keyword">(</span>1+max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl+HTDF1 = hr
</span>        avltree_lrotate <span class="keyword">(</span>k<span class="keyword">,</span> x<span class="keyword">,</span> hl<span class="keyword">,</span> tl<span class="keyword">,</span> hr<span class="keyword">,</span> tr<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [if]
</span>    <span class="keyword">end</span> <span class="comment">// end of [B]
</span>  <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>k0 := k<span class="keyword">;</span> x0 := x<span class="keyword">;</span> tr<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [avltree_takeout_min]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">//
</span><span class="comment">// HX-2010-03-25: unsafe but convenient to implement
</span><span class="comment">//
</span><span class="keyword">extern</span>
<span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
<a name="9893"><span class="dyncstdec">funmap_takeout_ptr <span class="staexp"><span class="keyword">{</span>l_res<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>map <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> k0<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp key</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">ptr l_res</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">bool</span></span></a>
<span class="comment">// end of [funmap_takeout]
</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_takeout_ptr <span class="staexp"><span class="keyword">{</span>l_res<span class="keyword">}</span></span>
  <span class="keyword">(</span>m<span class="keyword">,</span> k0<span class="keyword">,</span> cmp<span class="keyword">,</span> p_res<span class="keyword">)</span> <span class="keyword">=</span> b<span class="comment">(*removed*)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> takeout <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
      t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span>
    <span class="keyword">,</span> p_res<span class="keyword">:</span> <span class="staexp">ptr l_res</span><span class="keyword">,</span> b<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>bool? &gt;&gt; bool</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">avltree_dec <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">}</span></span> <span class="keyword">(</span>h<span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> sgn <span class="keyword">=</span> compare_key_key <span class="keyword">(</span>k0<span class="keyword">,</span> k<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">case+</span> 0 <span class="keyword">of</span>
        <span class="keyword">|</span> _ <span class="keyword">when</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">=&gt;</span> <span class="keyword">let</span>
            <span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">hl<span class="keyword">:</span>int</span><span class="keyword">]</span> tl <span class="keyword">=</span> takeout <span class="keyword">(</span>tl<span class="keyword">,</span> p_res<span class="keyword">,</span> b<span class="keyword">)</span>
            <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hl</span>
            <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hr</span>
          <span class="keyword">in</span>
            <span class="keyword">if</span> hr - hl &lt;= HTDF <span class="keyword">then</span> <span class="keyword">begin</span>
              B <span class="keyword">(</span>1+max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl+HTDF1 = hr
</span>              avltree_lrotate <span class="keyword">(</span>k<span class="keyword">,</span> x<span class="keyword">,</span> hl<span class="keyword">,</span> tl<span class="keyword">,</span> hr<span class="keyword">,</span> tr<span class="keyword">)</span>
            <span class="keyword">end</span> <span class="comment">// end of [if]
</span>          <span class="keyword">end</span> <span class="comment">// end of [sgn &lt; 0]
</span>        <span class="keyword">|</span> _ <span class="keyword">when</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">=&gt;</span> <span class="keyword">let</span>
            <span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">hr<span class="keyword">:</span>int</span><span class="keyword">]</span> tr <span class="keyword">=</span> takeout <span class="keyword">(</span>tr<span class="keyword">,</span> p_res<span class="keyword">,</span> b<span class="keyword">)</span>
            <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hl</span>
            <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hr</span>
          <span class="keyword">in</span>
            <span class="keyword">if</span> hl - hr &lt;= HTDF <span class="keyword">then</span> <span class="keyword">begin</span>
              B <span class="keyword">(</span>1+max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl=hr+HTDF1
</span>              avltree_rrotate <span class="keyword">(</span>k<span class="keyword">,</span> x<span class="keyword">,</span> hl<span class="keyword">,</span> tl<span class="keyword">,</span> hr<span class="keyword">,</span> tr<span class="keyword">)</span>
            <span class="keyword">end</span> <span class="comment">// end of [if]
</span>          <span class="keyword">end</span> <span class="comment">// end of [sgn &gt; 0]
</span>        <span class="keyword">|</span> _ <span class="comment">(*sgn = 0*)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> <span class="keyword">(</span>p_res &lt;&gt; null<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">let</span>
              <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span>pf<span class="keyword">,</span> fpf<span class="keyword">)</span> <span class="keyword">=</span> __assert <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
                <span class="keyword">extern</span> <span class="keyword">prfun</span> <a name="11456"><span class="dyncstdec"><span class="prfexp">__assert <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>itm? @ l_res<span class="keyword">,</span> itm @ l_res <span class="keyword">-&lt;&gt;</span> void<span class="keyword">)</span></span></span></span></a>
              <span class="keyword">}</span></span>
              <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_res := x
              <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fpf <span class="keyword">(</span>pf<span class="keyword">)</span></span>
            <span class="keyword">in</span>
              <span class="comment">// nothing
</span>            <span class="keyword">end</span> <span class="comment">// end of [val]
</span>            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> b := true
          <span class="keyword">in</span>
            <span class="keyword">case+</span> tr <span class="keyword">of</span>
            <span class="keyword">|</span> B _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
                <span class="keyword">var</span> k_min<span class="keyword">:</span> <span class="staexp">key?</span> <span class="keyword">and</span> x_min<span class="keyword">:</span> <span class="staexp">itm?</span>
                <span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">hr<span class="keyword">:</span>int</span><span class="keyword">]</span> tr <span class="keyword">=</span> avltree_takeout_min&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="keyword">(</span>tr<span class="keyword">,</span> k_min<span class="keyword">,</span> x_min<span class="keyword">)</span>
                <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hl</span>
                <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int hr</span>
              <span class="keyword">in</span>
                <span class="keyword">if</span> hl - hr &lt;= HTDF <span class="keyword">then</span> <span class="keyword">begin</span>
                  B <span class="keyword">(</span>1+max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span><span class="keyword">,</span> k_min<span class="keyword">,</span> x_min<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl=hr+HTDF1
</span>                  avltree_rrotate <span class="keyword">(</span>k_min<span class="keyword">,</span> x_min<span class="keyword">,</span> hl<span class="keyword">,</span> tl<span class="keyword">,</span> hr<span class="keyword">,</span> tr<span class="keyword">)</span>
                <span class="keyword">end</span> <span class="comment">// end of [if]
</span>              <span class="keyword">end</span> <span class="comment">// end of [B]
</span>            <span class="keyword">|</span> E _ <span class="keyword">=&gt;</span> tl
          <span class="keyword">end</span> <span class="comment">// end of [sgn = 0]
</span>      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> t <span class="keyword">where</span> <span class="keyword">{</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> b := false
      <span class="keyword">}</span> <span class="comment">// end of [E]
</span>  <span class="keyword">end</span> <span class="comment">// end of [takeout]
</span>  <span class="keyword">var</span> b<span class="keyword">:</span> <span class="staexp">bool</span> <span class="comment">// unitialized
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> m := takeout <span class="keyword">(</span>m<span class="keyword">,</span> p_res<span class="keyword">,</span> b<span class="keyword">)</span>
<span class="keyword">}</span> <span class="comment">// end of [funmap_takeout_ptr]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_takeout
  <span class="keyword">(</span>m<span class="keyword">,</span> k0<span class="keyword">,</span> cmp<span class="keyword">,</span> res<span class="keyword">)</span> <span class="keyword">=</span> ans <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">val</span> ans <span class="keyword">=</span> funmap_takeout_ptr&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="keyword">(</span>m<span class="keyword">,</span> k0<span class="keyword">,</span> cmp<span class="keyword">,</span> <span class="keyword">&amp;</span>res<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">b<span class="keyword">:</span>bool</span><span class="keyword">]</span> ans <span class="keyword">=</span> bool1_of_bool <span class="keyword">(</span>ans<span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> __assert <span class="keyword">(</span>view@ res<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
    <span class="keyword">extern</span> <span class="keyword">prfun</span> <a name="12823"><span class="dyncstdec"><span class="prfexp">__assert <span class="staexp"><span class="keyword">{</span>l_res<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">itm? @ l_res</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">(</span>opt <span class="keyword">(</span>itm<span class="keyword">,</span> b<span class="keyword">)</span> @ l_res<span class="keyword">)</span></span></span></span></a>
  <span class="keyword">}</span></span> <span class="comment">// end of [prval]
</span>  <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>view@ res := pf<span class="keyword">)</span></span>
<span class="keyword">}</span> <span class="comment">// end of [funmap_takeout]
</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_remove <span class="keyword">(</span>m<span class="keyword">,</span> k0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> funmap_takeout_ptr&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="keyword">(</span>m<span class="keyword">,</span> k0<span class="keyword">,</span> cmp<span class="keyword">,</span> null<span class="keyword">)</span>
<span class="comment">// end of [funmap_remove]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
fun{key,itm:t@ype}
funmap_foreach_funenv
  {v:view} {vt:viewtype} (
  pf: !v | m: map (key, itm), f: (!v | key, itm, !vt) -&lt;clo&gt; void, env: !vt
) :&lt;&gt; void // end of [funmap_foreach_funenv]
*)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_foreach_funenv <span class="staexp"><span class="keyword">{</span>v<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>vt<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> m<span class="keyword">,</span> f<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> foreach <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> m<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> foreach <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>v</span></span> <span class="keyword">|</span> t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>vt</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        foreach <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> tl<span class="keyword">,</span> env<span class="keyword">)</span><span class="keyword">;</span> f <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> k<span class="keyword">,</span> x<span class="keyword">,</span> env<span class="keyword">)</span><span class="keyword">;</span> foreach <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> tr<span class="keyword">,</span> env<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [foreach]
</span><span class="keyword">}</span> <span class="comment">// end of [funmap_foreach_funenv]
</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_foreach_fun
  <span class="keyword">(</span>m<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//
</span>  <span class="keyword">val</span> f <span class="keyword">=</span> coerce <span class="keyword">(</span>f<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
    <span class="keyword">extern</span> <span class="keyword">castfn</span> <a name="13840"><span class="dyncstdec">coerce
      <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="keyword">fun</span><span class="keyword">&gt;</span> void</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">(</span><span class="keyword">!</span>unit_v <span class="keyword">|</span> key<span class="keyword">,</span> itm<span class="keyword">,</span> <span class="keyword">!</span>ptr<span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="keyword">fun</span><span class="keyword">&gt;</span> void</span></span></a>
  <span class="keyword">}</span> <span class="comment">// end of [val]
</span><span class="comment">//
</span>  <span class="keyword">prval</span> <span class="prfexp">pfu <span class="keyword">=</span> unit_v <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> funmap_foreach_funenv&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">{</span>unit_v<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>ptr<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pfu</span> <span class="keyword">|</span> m<span class="keyword">,</span> f<span class="keyword">,</span> null<span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">unit_v <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pfu</span>
<span class="comment">//  
</span><span class="keyword">in</span>
  <span class="comment">// nothing
</span><span class="keyword">end</span> <span class="comment">// end of [funmap_foreach_fun]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_foreach_clo <span class="staexp"><span class="keyword">{</span>v<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> m<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">=</span> foreach <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> m<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> foreach <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>v</span></span> <span class="keyword">|</span> t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span><span class="keyword">(</span><span class="keyword">!</span>v <span class="keyword">|</span> key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>clo<span class="keyword">&gt;</span> void</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        foreach <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> tl<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">;</span> f <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> k<span class="keyword">,</span> x<span class="keyword">)</span><span class="keyword">;</span> foreach <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> tr<span class="keyword">,</span> f<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [foreach]
</span><span class="keyword">}</span> <span class="comment">// end of [funmap_foreach_clo]
</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_foreach_cloref <span class="keyword">(</span>m<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> f <span class="keyword">=</span> __cast <span class="keyword">(</span>f<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span> <span class="keyword">extern</span> <span class="keyword">castfn</span> <a name="14660"><span class="dyncstdec">__cast
    <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> void</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">(</span><span class="keyword">!</span>unit_v <span class="keyword">|</span> key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> void</span></span></a>
  <span class="keyword">}</span> <span class="comment">// end of [val]
</span>  <span class="keyword">typedef</span> <span class="staexp"><a name="14771"><span class="stacstdec">clo_type <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">!</span>unit_v <span class="keyword">|</span> key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>clo<span class="keyword">&gt;</span> void</span></a></span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">vbox pf_f</span> <span class="keyword">|</span> p_f<span class="keyword">)</span> <span class="keyword">=</span> cloref_get_view_ptr <span class="staexp"><span class="keyword">{</span>clo_type<span class="keyword">}</span></span> <span class="keyword">(</span>f<span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">pf0 <span class="keyword">=</span> unit_v <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">$effmask_ref</span>
    <span class="keyword">(</span>funmap_foreach_clo&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">{</span>unit_v<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf0</span> <span class="keyword">|</span> m<span class="keyword">,</span> <span class="keyword">!</span>p_f<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">unit_v <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf0</span>
<span class="keyword">in</span>
  <span class="comment">// empty
</span><span class="keyword">end</span> <span class="comment">// end of [funmap_foreach_cloref]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
funmap_listize <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">typedef</span> <span class="staexp"><a name="15136"><span class="stacstdec">keyitm <span class="keyword">=</span> <span class="keyword">@(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span></a></span>
  <span class="keyword">viewtypedef</span> <span class="staexp"><a name="15171"><span class="stacstdec">res_vt <span class="keyword">=</span> List_vt keyitm</span></a></span>
  <span class="keyword">fun</span> listize <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
    t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">res_vt</span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp">res_vt</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>
        _<span class="comment">(*h*)</span><span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tl<span class="keyword">,</span> tr
      <span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> res <span class="keyword">=</span> listize <span class="keyword">(</span>tr<span class="keyword">,</span> res<span class="keyword">)</span>
        <span class="keyword">val</span> res <span class="keyword">=</span> list_vt_cons <span class="staexp"><span class="keyword">{</span>keyitm<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">(</span>k<span class="keyword">,</span> x<span class="keyword">)</span><span class="keyword">,</span> res<span class="keyword">)</span>
        <span class="keyword">val</span> res <span class="keyword">=</span> listize <span class="keyword">(</span>tl<span class="keyword">,</span> res<span class="keyword">)</span>
      <span class="keyword">in</span>
        res
      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> res
  <span class="comment">// end of [listize]
</span><span class="keyword">in</span>
  listize <span class="keyword">(</span>xs<span class="keyword">,</span> list_vt_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [funmap_listize]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [funmap_avltree.dats] *)</span>
</pre>
</body>
</html>
